package lsdsoft.zeus.methods;


import java.io.*;
import java.lang.reflect.*;
import java.util.*;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.Timer;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.table.*;

//import com.borland.jbcl.layout.*;
import lsdsoft.metrolog.*;
import lsdsoft.metrolog.unit.*;
import lsdsoft.units.*;
import lsdsoft.util.*;
import lsdsoft.welltools.im.ion1.*;
import lsdsoft.zeus.*;
import lsdsoft.zeus.report.*;
import lsdsoft.zeus.ui.*;
import bsh.*;
import java.net.*;
import java.text.*;


/**
 * <p>Title: Обозреватель для прибора ИНКЛ-75</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2004</p>
 * <p>Company: Ural-Geo</p>
 * @author lsdsoft
 * @version 0.9
 */

public class InklMethodsViewer
    extends AbstractMethodsViewer
    implements SignalEventListener {

    //Interpreter shell = new Interpreter();
    class Command {
        protected Class[] params = {};

        String description;
        String name;
        String method;
        InklMethodsViewer viewer;
        public Command( InklMethodsViewer viewer, String method, String name,
                        String desc ) {
            this.viewer = viewer;
            this.method = method;
            this.name = name;
            this.description = desc;
        }

        void execute() throws Exception {
            //Method[] meths = viewer.getClass().getMethods();
            Method method = viewer.getClass().getMethod( this.method, params );
            //if ( method != null ) {
            method.invoke( viewer, null );
            //}

        }

        public String toString() {
            return name;
        }
    };


    Command commandMeasure = new Command( this, "doMeasure", "замер в точке",
                                          "" );

    private Command[] commands = {
        new Command( this, "doCalibrationFull", "калибровка полностью", "" ),
        new Command( this, "doCalibrationRotate", "калибровка угла поворота",
                     "" ),
        new Command( this, "doCalibrationZenith", "калибровка зенитного угла",
                     "" ),
        new Command( this, "doCalibrationZenithPart",
                     "калибровка зенитного угла частично", "" ),
        new Command( this, "doCalibrationAzimuth",
                     "калибровка азимутального угла", "" ),
        new Command( this, "doCalibrationAzimuthPart",
                     "калибровка азимутального угла частично", "" ),
        //new Command( this, "doJoinRotates", "совмещение углов поворота", "" ),
    };
    ///////////////////////////////////////////////////////////////////////////
    class ChangeAction
        extends AbstractAction {
        public ChangeAction() {
            putValue( Action.NAME, "Изменить..." );
        }

        public void actionPerformed( ActionEvent e ) {
            doChange();
        }
    }


    Action changeAction = new ChangeAction();
    class MeasureAction
        extends AbstractAction {
        public MeasureAction() {
            putValue( Action.NAME, "Замер" );
        }

        public void actionPerformed( ActionEvent e ) {
            execCommand( commandMeasure );
        }
    }


    Action measureAction = new MeasureAction();
    InklMethodsViewer viewer = this;
    MouseAdapter madapter = new MouseAdapter() {
        public void mouseClicked( MouseEvent e ) {
            JTable table = ( JTable )e.getSource();

            if ( e.getButton() == MouseEvent.BUTTON3 ) {
                int row = table.rowAtPoint( e.getPoint() );
                table.setRowSelectionInterval( row, row );
                tablePopup.show( e.getComponent(), e.getX(), e.getY() );
            }
            /*
                         if( e.getButton() != MouseEvent.BUTTON2 ) {
                tablePopup.show(e.getComponent(), e.getX(), e.getY());
                return;
                         }
                         if ( e.getButton() != MouseEvent.BUTTON3 ) {
                return;
                         }
                         int row = table.getSelectedRow();
                 selectedContainer = tables[tabbedTables.getSelectedIndex()];
                         if ( row >= 0 ) {
                MeasureChainEditor.edit( selectedContainer.measureTable.
                                         getChain( row ), viewer );
                selectedContainer.measureTable.calc();
                table.repaint();
                         }
             */
        }
    };

    int selectedCommand = 1;
    Date startTime = new Date();
    // нормы погрешности на ИНКЛ-75 (азимут, зенит, поворот)
    private final static double[] INKL_ERRORS = {2.0, 0.5, 3.0};
    private final static double[] UAKSI_ERRORS = {0.5, 0.08, 1};

    Timer timeUpdater = new Timer( 1000, new ActionListener() {
        public void actionPerformed( ActionEvent evt ) {
            updateTime();
            addToTracker();
        }
    } );

    MeasureDatas datas = null;
    AbstractCheckUnit unit = null;
    ChannelDataSource toolSource = null;
    InclinometerAngles toolAngles = new InclinometerAngles();
    InclinometerAngles accAngles = new InclinometerAngles();
    boolean toCheckToolNumber = false;
    JTabbedPane tabbedTables = new JTabbedPane();
    JPanel panelZ = new JPanel();
    JPanel panelY = new JPanel();
    JPanel panelX = new JPanel();
    //JScrollPane scrollPaneX = new JScrollPane();
    //JScrollPane scrollPaneY = new JScrollPane();
    //JScrollPane scrollPaneZ = new JScrollPane();
    // цифровые индикаторы
    DigitalDisplay displayAX = new DigitalDisplay( 6, 2 );
    DigitalDisplay displayAY = new DigitalDisplay( 6, 2 );
    DigitalDisplay displayAZ = new DigitalDisplay( 6, 2 );
    DigitalDisplay displayTX = new DigitalDisplay( 6, 2 );
    DigitalDisplay displayTY = new DigitalDisplay( 6, 2 );
    DigitalDisplay displayTZ = new DigitalDisplay( 6, 2 );
    ImageIcon iconOff = Zeus.createImageIcon( "images/conn_off.png" );
    ImageIcon iconOn = Zeus.createImageIcon( "images/conn_on.png" );

    //JTable tableX;
    //JTable tableY;
    //JTable tableZ;
    JComboBox cbZenRotates = new JComboBox();
    JLabel jLabel1 = new JLabel();
    JLabel jLabel2 = new JLabel();
    JComboBox cbAzZeniths = new JComboBox();
    TableContainer tables[] = {
        new TableContainer(), new TableContainer(), new TableContainer()};
    CommandExecuter executer;
    JToolBar jToolBar1 = new JToolBar();
    JButton bSave = new JButton();
    JPanel panelDisplay = new JPanel();
    JPanel panelHeader = new JPanel();
    JLabel jLabel6 = new JLabel();
    JLabel jLabel7 = new JLabel();
    JLabel jLabel5 = new JLabel();
    JLabel jLabel8 = new JLabel();
    JPanel panelAcc = new JPanel();
    JLabel jLabel3 = new JLabel();
    //JImage imgDigAX = new JImage( displayAX.getImage() );
    //JImage imgDigAY = new JImage( displayAY.getImage() );
    //JImage imgDigAZ = new JImage( displayAZ.getImage() );
    JPanel panelTool = new JPanel();
    //JImage imgDigTX = new JImage( displayTX.getImage() );
    JLabel jLabel4 = new JLabel();
    //JImage imgDigTY = new JImage( displayTY.getImage() );
    //JImage imgDigTZ = new JImage( displayTZ.getImage() );
    //VerticalFlowLayout verticalFlowLayout1 = new VerticalFlowLayout();
    //BoxLayout2 boxLayout21 = new BoxLayout2();
    //BoxLayout2 boxLayout22 = new BoxLayout2();
    TitledBorder titledBorder1;
    Border border1;
    TitledBorder titledBorder2;
    JButton bConnect = new JButton();
    Border border2;
    TitledBorder titledBorder3;
    ButtonGroup bgWhat = new ButtonGroup();
    TitledBorder titledBorder4;
    JLabel jLabel9 = new JLabel();
    JComboBox cbDo = new JComboBox();
    JButton bStart = new JButton();
    JPanel jPanel1 = new JPanel();
    JLabel jLabel10 = new JLabel();
    JLabel jLabel11 = new JLabel();
    JLabel lTimeStart = new JLabel();
    JLabel lTimeElapsed = new JLabel();
    JLabel lMessage1 = new JLabel();
    JLabel lMessage2 = new JLabel();
    JLabel lMessage3 = new JLabel();
    JButton bStop = new JButton();
    TableContainer selectedContainer;
    JPopupMenu tablePopup = new JPopupMenu();
    JMenuItem miChange = new JMenuItem();
    JMenuItem miMeasure = new JMenuItem();
    private JButton bProtocol = new JButton();
    private JButton bImportLas = new JButton();
    private JButton bSaveTracker = new JButton();
    DecimalFormat df;

    // new tracker with 4 tracks: time, azimut, zenit, rotate
    private Tracker tracker = new Tracker(4);

    //private final char PLUS_MINUS = '\u0177';

    class TableContainer {
        JTable table;
        MeasureTable measureTable;
        JScrollPane scrollPane = new JScrollPane();
        public void init() {
            table = new JTable( new MeasureTableModel( measureTable ) );
            Font font = new Font( "Dialog", 0, 14 );
            // init tableX
            table.setFont( font );
            table.setBorder( BorderFactory.createLineBorder( Color.black ) );
            table.setMinimumSize( new Dimension( 300, 200 ) );
            table.setAutoResizeMode( JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS );
            table.setRowHeight( 16 );
            table.addMouseListener( madapter );
            //tables[i].table.setCellSelectionEnabled(false);
            table.setSelectionMode( ListSelectionModel.
                                    SINGLE_SELECTION );
            table.add( tablePopup );
            scrollPane.setAutoscrolls( true );
            scrollPane.getViewport().add( table, null );

        }
    }


    public InklMethodsViewer() {
        try {
            df = (DecimalFormat)NumberFormat.getInstance(Locale.ENGLISH);
            df.applyPattern("#0.00");
        } catch ( Exception e ) {
            e.printStackTrace();
        }
    }
    protected void addToTracker() {
        double[] vals = new double[4];
        long time = System.currentTimeMillis();
        vals[0] = time;
        //long t2 = (long)vals[0];
        vals[1] = accAngles.azimuth.getValue();
        vals[2] = accAngles.zenith.getValue();
        vals[3] = accAngles.rotate.getValue();
        tracker.points.add(vals);
    }

    public void setProperties( Properties props ) {
        properties = ( Properties )props.clone();
    }

    public void setMeasureDatas( MeasureDatas datas ) {
        this.datas = datas;
        datas.calc();
    }

    protected void selectTables() {
        Vector tables = datas.selectTables( "type", "azimuth" );
        if ( tables.size() > 0 ) {
            this.tables[2].measureTable = ( MeasureTable )tables.get( 0 );
        }
        tables = datas.selectTables( "type", "zenith" );
        if ( tables.size() > 0 ) {
            this.tables[1].measureTable = ( MeasureTable )tables.get( 0 );
        }
        tables = datas.selectTables( "type", "rotate" );
        if ( tables.size() > 0 ) {
            this.tables[0].measureTable = ( MeasureTable )tables.get( 0 );
        }
    }

    protected void initZenithTab() {
        Vector tables = datas.selectTables( "type", "zenith" );
        int size = tables.size();
        cbZenRotates.removeAllItems();
        for ( int i = 0; i < size; i++ ) {
            MeasureTable table = ( MeasureTable )tables.get( i );
            String value = table.getProperty( "rotate" );
            if ( value != null ) {
                cbZenRotates.addItem( value );
            }
        }

    }

    protected void initAzimuthTab() {
        Vector tables = datas.selectTables( "type", "azimuth" );
        int size = tables.size();
        cbAzZeniths.removeAllItems();
        for ( int i = 0; i < size; i++ ) {
            MeasureTable table = ( MeasureTable )tables.get( i );
            String value = table.getProperty( "zenith" );
            if ( value != null ) {
                cbAzZeniths.addItem( value );
            }
        }
    }

    protected void buildTables() {
        for ( int i = 0; i < 3; i++ ) {
            tables[i].init();
            tables[i].table.addMouseListener( madapter );
            //tables[i].table.setCellSelectionEnabled(false);
            tables[i].table.setSelectionMode( ListSelectionModel.
                                              SINGLE_SELECTION );
            tables[i].table.add( tablePopup );
        }

    }

    protected void changeAzimuthTable() {
        String value = ( String )cbAzZeniths.getSelectedItem();
        Vector tables = datas.selectTypedTables( "azimuth", "zenith", value );
        if ( tables.size() > 0 ) {
            this.tables[2].measureTable = ( MeasureTable )tables.get( 0 );
        }
        this.tables[2].init();
    }

    protected void changeZenithTable() {
        String value = ( String )cbZenRotates.getSelectedItem();
        Vector tables = datas.selectTypedTables( "zenith", "rotate", value );
        if ( tables.size() > 0 ) {
            this.tables[1].measureTable = ( MeasureTable )tables.get( 0 );
        }
        this.tables[1].init();
    }

    private void redrawToolValues() {
        if ( toolSource.isConnected() ) {
            displayTX.render( toolAngles.azimuth.getValue() );
            displayTY.render( toolAngles.zenith.getValue() );
            displayTZ.render( toolAngles.rotate.getValue() );
        } else {
            displayTX.renderClear();
            displayTY.renderClear();
            displayTZ.renderClear();
        }
        displayTX.repaint();
        displayTY.repaint();
        displayTZ.repaint();
    }

    private void redrawAccurateValues() {
        if ( unit.isConnected() ) {
            displayAX.render( accAngles.azimuth.getValue() );
            displayAY.render( accAngles.zenith.getValue() );
            displayAZ.render( accAngles.rotate.getValue() );
        } else {
            displayAX.renderClear();
            displayAY.renderClear();
            displayAZ.renderClear();
        }
        displayAX.repaint();
        displayAY.repaint();
        displayAZ.repaint();
    }
    public String formatValue(Value val) {
        String s;
        s = df.format(val.value) + " @ " + df.format( val.delta );
        return s;
    }

    public void signalEvent( SignalEvent ev ) {
        SignalSource src = ev.getSource();
        if ( src.equals( toolSource ) ) {
            if ( ev.getSignal() == SignalEvent.SIG_DATA_ARRIVED ) {
                Channel chan = toolSource.getChannel( "angles" );
                if ( chan == null ) {
                    chan = toolSource.getChannel( "values" );
                }
                if ( chan != null ) {
                    System.out.println("### tool");
                    Value val = chan.getValue( 0 ).getAsValue();
                    System.out.println("Az=" + formatValue(val)+';');
                    val = chan.getValue( 1 ).getAsValue();
                    System.out.println("Zn=" + formatValue(val)+';');
                    val = chan.getValue( 2 ).getAsValue();
                    System.out.println("Rt=" + formatValue(val)+';');


                    //toolAngles.zenit = chan.getValue( 1 ).angle;
                    //toolAngles.rotate = chan.getValue( 2 ).angle;
                    toolAngles.azimuth.setAngle( chan.getValue( 0 ).getAsDouble() );
                    toolAngles.zenith.setAngle( chan.getValue( 1 ).getAsDouble() );
                    toolAngles.rotate.setAngle( chan.getValue( 2 ).getAsDouble() );

                    redrawToolValues();
                }
                if(toCheckToolNumber) {
                    chan = toolSource.getChannel( "sensors" );
                    if ( chan != null ) {
                        // берем из канала датчиков 4-й и 5-й элемент содержащие номер прибора
                        // 4-й - старший байт, 5-й - младший
                        int number = chan.getValue( 4 ).getAsInteger() *
                            0x10000 +
                            chan.getValue( 5 ).getAsInteger();
                        System.out.println( "#" + number );
                        String strNum = "" + number;
                        if( !strNum.equals(datas.getToolNumber()) ) {
                            System.out.println( "invalid tool number!!!" );
                            toolSource.setProperty("tool.number", strNum);
                            datas.getWorkState().setToolNumber(strNum);
                            //datas.getProperties().setProperty("tool.number", strNum);
                            updateTitle();
                        }
                    }
                }
            }
            if ( ev.getSignal() == SignalEvent.SIG_TIMEOUT ) {
                UiUtils.showError( this, "Нет связи с прибором" );
            }

        } else
        if ( src.equals( unit ) ) {
            if ( ev.getSignal() == SignalEvent.SIG_DATA_ARRIVED ) {
                Channel chan = unit.getChannel( "angles" );
                if ( chan != null ) {
                    accAngles.azimuth.setAngle( chan.getValue( 0 ).getAsDouble() );
                    //System.out.println(df.format( chan.getValue( 0 ).getAsDouble()));
                    accAngles.zenith.setAngle( chan.getValue( 1 ).getAsDouble() );
                    accAngles.rotate.setAngle( chan.getValue( 2 ).getAsDouble() );
                    redrawAccurateValues();
                }

            } else
            if ( ev.getSignal() == SignalEvent.SIG_TIMEOUT ) {
                UiUtils.showError( this, "Нет связи с установкой" );
            }

        }

    }

    public void start() {
        boolean quit = false;
        try {
            //System.out.println(df.format(1.63));
            Zeus zeus = Zeus.getInstance();
            unit = DataFactory.createCalibrationRigForChannel("angles");
            //unit.init();
            unit.addSignalListener( this );
            //shell.source("aaa");
            //shell.e
            boolean b = Boolean.valueOf( zeus.getProperty( Zeus.PROP_WORK_NEW ) ).
                booleanValue();
            if ( b ) {
                datas = DataFactory.createMeasureDatas( DataFactory.getMethods(
                    "ion1_test.xml" ) );
                datas.setWorkState( workState );
            } else {
                String id = zeus.getProperty( Zeus.PROP_WORK_ID );
                datas = DataFactory.loadMeasureDatas( workState.getToolType(),
                    workState.getToolNumber(),
                    zeus.getProperty( Zeus.PROP_WORK_ID ) );
                workState = datas.getWorkState();
                assignAccDelta();

            }
            datas.ensurePointsCount( 4 );
            datas.calc();
            selectTables();
            buildTables();
            initZenithTab();
            initAzimuthTab();
            /*
            try {
                toolSource = DataFactory.createToolDataSource();
            } catch ( Exception ex ) {
                UiUtils.showError( this,
                                   ex.getLocalizedMessage() );
            }
            if ( toolSource == null ) {
                int res = UiUtils.showConfirmError( this,
                    "<html><center>Не удалось создать источник данных прибора" +
                    "<br>Продолжить?" );
                quit = res != 0;
            } else {
                toolSource.addSignalListener( this );
            }
*/
            jbInit();
            UiUtils.toScreenCenter( this );
            selectedContainer = tables[0];
            tabbedTables.setSelectedIndex( 0 );
            redrawAccurateValues();
            //redrawToolValues();
            /*
            // init shell vars
            shell.set( "zeus", zeus );
            shell.set( "unit", unit );
            //shell.eval( "importCommands(\"/data/commands/\")" );
            //ClassManager.
            //shell.getClassManager().addClassPath(new URL("file", "", "d:/zeus/data"));
            //URL url = shell.getClassManager().getResource( "test.bsh" );
            shell.getNameSpace().importCommands( "/commands" );
            //shell.eval("debug()");
            shell.source("data/commands/Test1.bsh");
            shell.eval( "Test1.print1()" );
            Object o = shell.get( "coms" );
            if ( o instanceof String ) {

            }
*/

        } catch ( Exception ex ) {
            UiUtils.showError( this, ex.getLocalizedMessage() );
            //ex.printStackTrace();
        }
        if ( !quit ) {
            this.setVisible( true );
        }
    }
    private void updateTitle() {
        String title = "Калибровка прибора " + workState.getToolName() + " № " +
                       workState.getToolNumber();
        if(workState.getToolType() == "ion1") {
            title += " | " + toolSource.getProperty( "table.filename" ) +
                " от " + toolSource.getProperty( "table.date" );
        }
        this.setTitle( title );

    }
    private Tracker buildTrackerFromDatas(){
        Tracker tracker = new Tracker( 4 );
        int tableCount = datas.size();
        for ( int i = 0; i < tableCount; i++ ) {
            MeasureTable table = datas.getTable( i );
            String type = table.getProperty( "type" );
            int iTrack = 1; // index in array of track nums
            if ( type.equals( "zenith" ) ) {
                iTrack = 2;
            } else
            if ( type.equals( "rotate" ) ) {
                iTrack = 3;
            }
            System.out.println( type );

            for ( int rr = 0; rr < table.size(); rr++ ) {
                MeasureChain mc = table.getChain( rr );
                int points = mc.size();
                for ( int pnt = 0; pnt < points; pnt++ ) {
                    MeasurePoint mp = mc.getPoint( pnt );
                    double acc = mp.getAccurateValue();
                    if ( acc != 0.0 ) {
                        double[] vals = new double[4];
                        vals[0] = mp.getTime();
                        System.out.println( ( long )vals[0] + " " +
                                            TextUtil.
                                            dateToString( mp.getDate(),
                            "HH:mm:ss" ) );
                        vals[iTrack] = acc;

                        tracker.points.add( vals );
                    }
                }
            }
        }
        // sort by time column
        tracker.sort(0);
        return tracker;
    }
    private void importLas() {
        InklImportLas imp = new InklImportLas();
        Tracker accTracker = buildTrackerFromDatas();

        System.out.println( "@AccstartTime:" +
                            TextUtil.dateToString( new Date( ( long )accTracker.
            getRow( 0 )[0] ), "HH:mm:ss" ));
        saveTracker(accTracker);
        imp.setAccTracker(accTracker);
        imp.setVisible(true);
        System.out.println( "@AccstartTime:" +
                            TextUtil.dateToString( new Date( ( long )accTracker.
            getRow( 0 )[0] ), "HH:mm:ss" ));
        if(imp.confirm) {
            Tracker toolTracker = imp.getTracker();
            double offset = imp.getOffset();
            double[] row = tracker.getRow(0);
            double toolStartTime = accTracker.getRow(0)[0];
            System.out.println( "@AccstartTime:" +
                                TextUtil.dateToString( new Date( ( long )
                toolStartTime ), "HH:mm:ss" ) );
            toolStartTime += offset*1000.0;
            System.out.println( "@AccstartTime:" +
                                TextUtil.dateToString( new Date( ( long )
                toolStartTime ), "HH:mm:ss" ) );
            String tt2 = TextUtil.dateToString( new Date((long)toolStartTime), "HH:mm:ss");
            System.out.println("__" + tt2);
            int trkSize = toolTracker.points.size();
            // заносим соответсвуюющее время в колонку (синхронизация)
            for(int i = 0; i < trkSize; i++) {
                row = toolTracker.getRow(i);
                row[imp.timeTrack] *= 1000.0; // преобразовывание секунд в милисекунды
                row[imp.timeTrack] += toolStartTime;
                Date dat = new Date((long)row[imp.timeTrack]);
                String tt = TextUtil.dateToString( dat, "HH:mm:ss");
                System.out.println(tt + " " + row[14] + " " + row[15] + " " + row[16]);

            }
            toolTracker.selectTrackForSearch(imp.timeTrack);
            //int rr = tracker.findRow(startTime.getTime());
            int tableCount = datas.size();
            for(int i = 0; i < tableCount; i++) {
                MeasureTable table = datas.getTable(i);
                String type = table.getProperty("type");
                int iTrack = 0; // index in array of track nums
                if(type.equals("zenith")) {
                    iTrack = 1;
                } else
                if(type.equals("rotate")) {
                    iTrack = 2;
                }
                int trackNum = imp.inklTracks[iTrack];
                System.out.println( type + "(" + trackNum + ")" );
                for(int rr = 0; rr < table.size(); rr++) {
                    MeasureChain mc =table.getChain(rr);
                    int points = mc.size();
                    for(int pnt = 0; pnt < points; pnt++) {
                        MeasurePoint mp = mc.getPoint(pnt);
                        System.out.println( "#search for: " +
                                            TextUtil.
                                            dateToString( mp.getDate(), "HH:mm:ss" ));

                        int iRow = toolTracker.findRow(mp.getTime());
                        double newToolVal = 0;
                        if( iRow < 0 ) {
                            double[] row1 = toolTracker.getRow( -iRow );
                            double[] row2 = toolTracker.getRow( -iRow - 1 );
                            if( row1 == null || row2 == null ) {
                                System.out.println("### error finding value");

                            } else  {
                                newToolVal = ( row1[trackNum] + row2[trackNum] ) /
                                    2.0;
                            }
                        } else {
                            row = toolTracker.getRow(iRow);
                            newToolVal = row[trackNum];
                        }
                        System.out.print(iRow + "# ");
                        // для азимута и поворота из крогового значения взять
                        // ближайшее от эталона расположенное на оси
                        if ( ( iTrack == 0 ) || ( iTrack == 2 ) ) {
                            double accVal = mp.getAccurateValue();
                            double d1 = Math.abs( accVal - newToolVal );
                            double d2 = Math.abs( accVal - (newToolVal - 360.0) );
                            if(d2 < d1) {
                                newToolVal -= 360.0;
                            }
                        }
                        Value newToolValue = new Value(newToolVal, INKL_ERRORS[iTrack] );
                        System.out.println(TextUtil.dateToString( mp.getDate(), "HH:mm:ss" ) + " " + mp.getAccurateValue() + " " + newToolValue);

                        mp.setToolValue(newToolValue);
                    }
                }

            }
            datas.calc();
            selectedContainer.table.repaint();

        }
        /*
        LasFile las = new LasFile();
        String lasName = "";
        try {
            las.load( new File( lasName ) );
        } catch ( Exception ex ) {
            System.err.println(ex.getLocalizedMessage());
        }
        Tracker tracker = new Tracker(las);
*/

    }
    private void saveTracker(Tracker tracker) {
        Date date = new Date();
        for(int i = 0; i < tracker.points.size(); i++) {
            double[] vals = tracker.getRow(i);
            date.setTime((long)vals[0]);
            System.out.print("#"+ i + " "+ TextUtil.dateToString( date, "HH:mm:ss" ) );
            for(int j = 1; j<vals.length; j++) {
                System.out.print( " " + vals[j] );
            }
            System.out.println();
        }

    }
    private void jbInit() throws Exception {
        //tables[0].init();
        titledBorder1 = new TitledBorder( "" );
        border1 = BorderFactory.createLineBorder( Color.black, 2 );
        titledBorder2 = new TitledBorder( BorderFactory.createLineBorder( Color.
            black, 1 ), "Показания " );
        border2 = BorderFactory.createLineBorder( SystemColor.controlText, 1 );
        titledBorder3 = new TitledBorder( BorderFactory.createLineBorder(
            SystemColor.controlText, 1 ), "Выполнить калибровку..." );
        titledBorder4 = new TitledBorder( "" );
        panelX.setLayout( null );
        panelZ.setLayout( new BorderLayout() );
        //table.setMinimumSize( new Dimension( , 0 ) );
        //table.setPreferredSize( new Dimension( 0, 0 ) );
        this.getContentPane().setLayout( null );
        this.setSize( 800, 600 );
        this.setState( Frame.NORMAL );
        updateTitle();
        //this.setExtendedState( 6 );
        tabbedTables.setBounds( new Rectangle( 9, 41, 478, 244 ) );
        //tabbedTables.addTab("Угол поворота", table);
        Font font = new Font( "Dialog", 0, 14 );
        // init tableX
        panelY.setMaximumSize( new Dimension( 500, 500 ) );
        panelY.setLayout( null );
        //scrollPaneY.setAutoscrolls( true );
        //scrollPaneY.setDebugGraphicsOptions( 0 );

        jLabel1.setText( "Угол поворота:" );
        jLabel1.setBounds( new Rectangle( 3, 9, 124, 15 ) );
        cbZenRotates.setBounds( new Rectangle( 110, 5, 115, 24 ) );
        cbZenRotates.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                cbZenRotates_actionPerformed( e );
            }
        } );

        jLabel2.setText( "Зенитный угол:" );
        jLabel2.setBounds( new Rectangle( 7, 9, 134, 15 ) );
        cbAzZeniths.setBounds( new Rectangle( 112, 7, 115, 24 ) );
        cbAzZeniths.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                cbAzZeniths_actionPerformed( e );
            }
        } );
        jToolBar1.setEnabled( true );
        //jToolBar1.setAlignmentY((float) 0.5);
        jToolBar1.setBorder( null );
        jToolBar1.setFloatable( false );
        jToolBar1.setBounds( new Rectangle( 1, 1, 480, 41 ) );
        // save button
        bSave.setText( "Сохранить" );
        bSave.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                bSave_actionPerformed( e );
            }
        } );
        // import las buuton
        bImportLas.setText( "Импорт LAS" );
        bImportLas.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                importLas();
            }
        } );
        // save tracker buuton
        /**
                 bSaveTracker.setText( "Save Tracker" );
         bSaveTracker.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                saveTracker(tracker);
            }
                 } );
         **/


        panelDisplay.setBorder( titledBorder2 );
        panelDisplay.setBounds( new Rectangle( 10, 286, 662, 150 ) );
        jLabel5.setHorizontalAlignment( SwingConstants.CENTER );
        jLabel5.setText( "АЗИМУТ" );
        jLabel5.setBounds( new Rectangle( 58, 7, 159, 15 ) );
        jLabel6.setHorizontalAlignment( SwingConstants.CENTER );
        jLabel6.setText( "ЗЕНИТ" );
        jLabel6.setBounds( new Rectangle( 243, 7, 162, 15 ) );
        jLabel7.setHorizontalAlignment( SwingConstants.CENTER );
        jLabel7.setText( "ПОВОРОТ" );
        jLabel7.setBounds( new Rectangle( 431, 7, 163, 15 ) );
        panelHeader.setLayout( null );
        panelAcc.setBorder( null );
        panelAcc.setDebugGraphicsOptions( 0 );
        panelAcc.setMinimumSize( new Dimension( 600, 17 ) );
        panelAcc.setPreferredSize( new Dimension( 640, 40 ) );
        panelAcc.setLayout( null );
        //panelAcc.setLayout(boxLayout21);
        jLabel3.setPreferredSize( new Dimension( 90, 15 ) );
        jLabel3.setHorizontalAlignment( SwingConstants.LEFT );
        jLabel3.setHorizontalTextPosition( SwingConstants.LEFT );
        jLabel3.setIconTextGap( 4 );
        jLabel3.setText( "По эталону" );
        jLabel3.setBounds( new Rectangle( 0, 4, 81, 31 ) );
        displayAX.setLocation( new java.awt.Point( 100, 310 ) );
        displayAX.setBounds( new Rectangle( 79, 1, 162, 35 ) );
        displayAY.setLocation( new java.awt.Point( 200, 380 ) );
        displayAY.setBounds( new Rectangle( 273, 1, 162, 35 ) );
        displayAZ.setLocation( new java.awt.Point( 380, 380 ) );
        displayAZ.setBounds( new Rectangle( 466, 2, 162, 35 ) );
        panelTool.setBorder( null );
        panelTool.setMinimumSize( new Dimension( 270, 30 ) );
        panelTool.setPreferredSize( new Dimension( 640, 40 ) );
        panelTool.setLayout( null );
        //panelTool.setLayout(boxLayout22);
        displayTX.setLocation( new java.awt.Point( 20, 420 ) );
        displayTX.setBounds( new Rectangle( 80, 3, 162, 35 ) );
        jLabel4.setPreferredSize( new Dimension( 90, 15 ) );
        jLabel4.setHorizontalAlignment( SwingConstants.LEFT );
        jLabel4.setHorizontalTextPosition( SwingConstants.LEFT );
        jLabel4.setIconTextGap( 4 );
        jLabel4.setText( "По прибору" );
        jLabel4.setBounds( new Rectangle( 2, 13, 84, 15 ) );
        displayTY.setLocation( new java.awt.Point( 240, 420 ) );
        displayTY.setBounds( new Rectangle( 273, 3, 162, 35 ) );
        displayTZ.setLocation( new java.awt.Point( 460, 420 ) );
        displayTZ.setBounds( new Rectangle( 466, 3, 162, 35 ) );
        panelHeader.setPreferredSize( new Dimension( 600, 30 ) );
        jLabel8.setBounds( new Rectangle( 0, 14, 0, 0 ) );
        bConnect.setBorder( BorderFactory.createRaisedBevelBorder() );
        bConnect.setMinimumSize( new Dimension( 82, 24 ) );
        bConnect.setPreferredSize( new Dimension( 82, 24 ) );
        bConnect.setToolTipText( "Подключиться к установке" );
        //bConnect.setActionCommand("Подключение");
        //bConnect.setBorderPainted(false);
        bConnect.setContentAreaFilled( true );
        //bConnect.setFocusPainted(true);
        bConnect.setIcon( iconOff );
        bConnect.setMargin( new Insets( 2, 14, 2, 14 ) );
        //bConnect.setMnemonic('0');
        //bConnect.setRolloverEnabled(true);
        bConnect.setText( "Подключение" );
        bConnect.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                switchConnect();
            }
        } );
        jLabel9.setText( "Выполнить:" );
        jLabel9.setBounds( new Rectangle( 502, 44, 94, 15 ) );
        cbDo.setBounds( new Rectangle( 502, 64, 264, 24 ) );
        bStart.setBounds( new Rectangle( 504, 95, 80, 29 ) );
        bStart.setPreferredSize( new Dimension( 80, 30 ) );
        bStart.setText( "Пуск" );
        bStart.addActionListener( new ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                startProcess();
            }
        } );
        jPanel1.setBorder( BorderFactory.createLineBorder( Color.black ) );
        jPanel1.setBounds( new Rectangle( 504, 133, 270, 153 ) );
        jPanel1.setLayout( null );
        jLabel10.setText( "Начало" );
        jLabel10.setBounds( new Rectangle( 7, 7, 53, 15 ) );
        jLabel11.setText( "Прошло" );
        jLabel11.setBounds( new Rectangle( 143, 8, 51, 15 ) );
        lTimeStart.setFont( new java.awt.Font( "Dialog", 1, 24 ) );
        lTimeStart.setText( "00:00:00" );
        lTimeStart.setBounds( new Rectangle( 5, 22, 117, 32 ) );
        lTimeElapsed.setBounds( new Rectangle( 138, 24, 117, 32 ) );
        lTimeElapsed.setText( "00:00:00" );
        lTimeElapsed.setFont( new java.awt.Font( "Dialog", 1, 24 ) );
        lMessage1.setText( "M1" );
        lMessage1.setBounds( new Rectangle( 7, 63, 253, 22 ) );
        lMessage2.setBounds( new Rectangle( 7, 83, 253, 22 ) );
        lMessage2.setText( "M2" );
        lMessage3.setBounds( new Rectangle( 7, 103, 253, 22 ) );
        lMessage3.setText( "M3" );
        bStop.setBounds( new Rectangle( 590, 95, 94, 29 ) );
        bStop.setPreferredSize( new Dimension( 84, 30 ) );
        bStop.setText( "Останов" );
        bStop.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                stopProcess( e );
            }
        } );
        //miMeasure.setText( "Замер" );
        miChange.setAction( changeAction );
        miMeasure.setAction( measureAction );
        bProtocol.setText( "Протокол" );
        bProtocol.addActionListener( new java.awt.event.ActionListener() {
            public void actionPerformed( ActionEvent e ) {
                bProtocol_actionPerformed( e );
            }
        } );
        tabbedTables.add( panelZ, "Угол поворота" );

        tables[2].scrollPane.setBounds( new Rectangle( 1, 41, 473, 169 ) );
        tables[1].scrollPane.setBounds( new Rectangle( 0, 38, 473, 179 ) );

        panelX.add( tables[2].scrollPane, null );
        panelY.add( tables[1].scrollPane, null );
        panelZ.add( tables[0].scrollPane, BorderLayout.CENTER );

        tabbedTables.add( panelY, "Зенитный угол" );
        panelY.add( jLabel1, null );
        panelY.add( cbZenRotates, null );
        tabbedTables.add( panelX, "Азимутальный угол" );
        //scrollPaneY.getViewport().add( tables[1].table, null );

        panelX.add( jLabel2, null );
        panelX.add( cbAzZeniths, null );
        this.getContentPane().add( jPanel1, null );
        jPanel1.add( jLabel10, null );
        jPanel1.add( jLabel11, null );
        jPanel1.add( lTimeStart, null );
        jPanel1.add( lTimeElapsed, null );
        this.getContentPane().add( bStart, null );
        this.getContentPane().add( cbDo, null );
        this.getContentPane().add( jLabel9, null );
        this.getContentPane().add( panelDisplay, null );
        panelHeader.add( jLabel8, null );
        panelHeader.add( jLabel7, null );
        panelHeader.add( jLabel6, null );
        panelHeader.add( jLabel5, null );
        panelDisplay.add( panelHeader, null );
        panelDisplay.add( panelAcc, null );
        panelAcc.add( displayAY, null );
        panelAcc.add( displayAX, null );
        panelAcc.add( displayAZ, null );
        panelAcc.add( jLabel3, null );
        panelDisplay.add( panelTool, null );
        panelTool.add( displayTX, null );
        panelTool.add( displayTY, null );
        panelTool.add( displayTZ, null );
        panelTool.add( jLabel4, null );

        displayAX.renderClear();
        displayAY.renderClear();
        displayAZ.renderClear();

        this.getContentPane().add( jToolBar1, null );
        jToolBar1.add( bSave, null );
        jToolBar1.addSeparator( new Dimension( 10, 10 ) );
        jToolBar1.add( bConnect, null );
        jToolBar1.add( bProtocol, null );
        jToolBar1.add( bImportLas, null );
        //jToolBar1.add( bSaveTracker, null );

        this.getContentPane().add( tabbedTables, null );
        jPanel1.add( lMessage2, null );
        jPanel1.add( lMessage3, null );
        jPanel1.add( lMessage1, null );
        this.getContentPane().add( bStop, null );
        tablePopup.add( miChange );
        tablePopup.add( miMeasure );

        //scrollPaneX.getViewport().add( tables[0].table, null );
        //scrollPaneZ.getViewport().add( tables[2].table, null );
        tabbedTables.setSelectedComponent( panelX );
        buildToolLabel();
        for ( int i = 0; i < commands.length; i++ ) {
            cbDo.addItem( commands[i] );
        }
        clearMessages();

        this.setDefaultCloseOperation( DO_NOTHING_ON_CLOSE );
    }


    void waitForValue( double value, char plane ) {
        for ( ; ; ) {

            try {
                double val = Double.parseDouble( unit.getValue( plane ).
                                                 toString() );
                if ( Math.abs( val - value ) < 0.5 ) {
                    break;
                }
                Thread.currentThread().sleep( 500 );
            } catch ( Exception ex ) {
                System.err.println( ex );
            }
        }
    }

    void doMeasure( MeasureTable table, int row, char plane ) {
        Channel achan = unit.getChannel( "angles" );
        //Channel tchan = toolSource.getChannel( "angles" );
        if ( achan == null ) {
            System.err.println( "Not available channel for measure" );
            return;
        }
        int subchan = planeToIndex( plane );
        MeasureChain chain = table.getChain( row );
        if ( chain == null ) {
            System.err.println( "No chain for row " + row );
            return;
        }
        int size = chain.size();
        if ( size < 4 ) {
            do {
                chain.addPoint();
                size = chain.size();
            }
            while ( size < 4 );
        }

        //size = 1;
        for ( int i = 0; i < size; i++ ) {
            lMessage3.setText( "Замер " + ( i + 1 ) );
            //System.out.print( "\nMeasure " + ( i + 1 ) );
            MeasurePoint point = chain.getPoint( i );
            System.out.print( '.' );
            point.setAccurateValue( doMeasureAccurate( plane ) );
            // set current time of measure
            point.time.setTime(System.currentTimeMillis());
            System.out.print( ',' );
            /*
            Value value = doMeasureTool( plane );
            if ( value.value > 350 ) {
                value.value -= 360;
            }
            point.setToolValue( value );
            */
            lMessage3.setText( "" );
        }
        chain.calc();

    }

    private int planeToIndex( char plane ) {
        int subchan = 0;
        if ( plane == 'y' ) {
            subchan = 1;
        } else if ( plane == 'z' ) {
            subchan = 2;
        }
        return subchan;
    }

    Value doMeasureAccurate( char plane ) {
        Value val = new Value();
        //double err = 0;
        int subchan = planeToIndex( plane );
        Channel chan = unit.getChannel( "angles" );
        //Channel chan2 = unit.getChannel( "errnorm" );
        for ( int i = 0; i < 4; i++ ) {
            unit.waitNewData();
            val.add(chan.getValue( subchan ).getAsValue());
        }
        //if(chan2 != null) {
        //    err = chan2.getValue(subchan).getAsDouble();
       // }
        val.value /= 4.0;
        val.delta /= 4.0;
        return val;
    }

    Value doMeasureTool( char plane ) {
        double value = 0;
        double err = 0;
        int subchan = planeToIndex( plane );
        Channel chan = toolSource.getChannel( "angles" );
        Channel chan2 = toolSource.getChannel( "errnorm" );
        if ( chan == null ) {
            /** @todo throw exce */
            return new Value();
        }
        for ( int i = 0; i < 4; i++ ) {
            toolSource.waitNewData();
            double v1 = chan.getValue( subchan ).getAsDouble();
            if ( v1 > 350 ) {
                v1 -= 360;
            }
            value += v1;
            if( chan2 != null) {
                err += chan2.getValue( subchan ).getAsDouble();
            }
        }
        value /= 4.0;
        err /= 4.0;
        return new Value(value, err);
    }

    void doWaitComplete( char plane ) {
        unit.waitNewData();
        unit.waitNewData();
        unit.waitNewData();
        unit.waitNewData();

        try {
            while ( !unit.isComplete( plane ) ) {
                Thread.sleep( 500 );
            }
        } catch ( InterruptedException ex ) {
        }
    }

    /**
     * Совмещение показаний угла поворота установки и прибора.
     * Совмещение производтся при зените 90 градусов.
     */
    public void doJoinRotates() throws Exception {
        clearMessages();
        lMessage1.setText( "Совмещение углов поворота" );
        UAKSI2CheckUnit unit = ( UAKSI2CheckUnit )this.unit;
        // сбрасываем поправку по повороту
        InclinometerAngles ang = unit.getAccurateDelta();
        ang.rotate.setAngle( 0 );
        // выходим на 90 градусов по зениту
        lMessage2.setText( "Выход на зенит 90 град" );
        unit.goToPoint( 'y', 90 );
        doWaitComplete( 'y' );
        lMessage2.setText( "Совмещение углов" );
        ang.rotate.setAngle( doMeasureAccurate( 'z' ).value - doMeasureTool( 'z' ).value );
        lMessage2.setText( "Совмещение выполнено" );

    }

    char nameToPlane( String tableName ) {
        char plane = 'z';
        if ( tableName.equals( "azimuth" ) ) {
            plane = 'x';
        } else
        if ( tableName.equals( "zenith" ) ) {
            plane = 'y';
        }
        return plane;
    }

    void doGoTo( char plane, Double value ) {
        try {
            String mess = "Задание азимутального угла ";
            if ( plane == 'y' ) {
                mess = "Задание зенитного угла ";
            }
            if ( plane == 'z' ) {
                mess = "Задание угла поворота ";
            }
            lMessage2.setText( mess + value );
            unit.goToPoint( plane, value );
            doWaitComplete( plane );
            lMessage2.setText( "" );
        } catch ( Exception ex ) {
            ex.printStackTrace();
        }

    }

    void doCalibrationTable( MeasureTable workTable ) {
        String name = workTable.getProperty( "name" );
        int pointsCount = workTable.size();
        char plane = nameToPlane( name );

        int first = 0;
        int inc = 1;
        Double firstPoint = new Double( workTable.getChain( 0 ).
                                        getReproductionValue() );
        Double lastPoint = new Double( workTable.getChain( pointsCount - 1 ).
                                       getReproductionValue() );
        Value current = doMeasureAccurate( plane );
        if ( Math.abs( current.value - firstPoint.doubleValue() ) <
             Math.abs( current.value - lastPoint.doubleValue() ) ) {
            first = 0;
            inc = 1;
        } else {
            first = pointsCount - 1;
            inc = -1;
        }
        for ( int i = 0; i < pointsCount; i++, first += inc ) {
            try {
                Double value = new Double( workTable.getChain( first ).
                                           getReproductionValue() );
                doGoTo( plane, value );
                Thread.sleep( 10000 );
                doMeasure( workTable, first, plane );
                selectedContainer.table.repaint();
                //tables[2].table.repaint();
            } catch ( Exception ex ) {
                System.err.println( ex.getMessage() );
                ex.printStackTrace();
            }
        }

    }

    public void doCalibrationFull() throws Exception {
        //doJoinRotates();
        doCalibrationRotate();
        doCalibrationZenith();
        doCalibrationAzimuth();
    }

    public void doCalibrationRotate() {
        selectedContainer = tables[0];
        lMessage1.setText( "Калибровка угла поворота" );
        doGoTo( 'y', new Double( 4.0 ) );
        MeasureTable workTable = selectedContainer.measureTable;
        doCalibrationTable( workTable );
        lMessage2.setText( "Калибровка выполнена" );
    }

    public void doCalibrationZenith() {
        int size = cbZenRotates.getItemCount();
        for ( int i = 0; i < size; i++ ) {
            cbZenRotates.setSelectedIndex( i );
            changeZenithTable();
            doCalibrationZenithPart();
        }

    }

    public void doCalibrationZenithPart() {
        clearMessages();
        selectedContainer = tables[1];
        lMessage1.setText( "Калибровка зенитного угла" );
        MeasureTable workTable = selectedContainer.measureTable;
        Double rotate = new Double( workTable.getProperty( "rotate" ) );
        doGoTo( 'z', rotate );
        doCalibrationTable( workTable );
        lMessage2.setText( "Калибровка выполнена" );

    }

    public void doCalibrationAzimuth() {
        int size = cbAzZeniths.getItemCount();
        for ( int i = 0; i < size; i++ ) {
            cbAzZeniths.setSelectedIndex( i );
            changeAzimuthTable();
            doCalibrationAzimuthPart();
        }
    }

    public void doCalibrationAzimuthPart() {
        clearMessages();
        selectedContainer = tables[2];
        lMessage1.setText( "Калибровка азимутального угла" );
        MeasureTable workTable = selectedContainer.measureTable;
        Double zenith = new Double( workTable.getProperty( "zenith" ) );
        doGoTo( 'y', zenith );
        doGoTo( 'z', new Double(45.0) );
        //lMessage2.setText( "Поиск максимального отклонения" );
        // перед выборкой угла поворота выставляем прибор на север
        //doGoTo( 'x', new Double( 0 ) );
        //doFindMaxDeviation();
        doCalibrationTable( workTable );
        lMessage2.setText( "Калибровка выполнена" );
    }

    public void doChange() {
        selectedContainer = tables[tabbedTables.getSelectedIndex()];
        JTable table = selectedContainer.table;
        int row = table.getSelectedRow();
        MeasureChainEditor.edit( selectedContainer.measureTable.
                                 getChain( row ), viewer );
        selectedContainer.measureTable.calc();
        table.repaint();

    }

    public void doMeasure() {
        selectedContainer = tables[tabbedTables.getSelectedIndex()];
        MeasureTable workTable = selectedContainer.measureTable;
        JTable table = selectedContainer.table;
        int row = table.getSelectedRow();
        String name = workTable.getProperty( "name" );
        char plane = nameToPlane( name );
        doMeasure( workTable, row, plane );
        table.repaint();
    }

    /**
     * Поиск максимального отклонения азимута в зависимости от поворота
     */
    public void doFindMaxDeviation() {
        double max = 0;
        double rotate = 0;
        for ( double r = 0; r < 332; r += 30 ) {
            doGoTo( 'z', new Double( r ) );
            Util.delay( 8000 );
            double acc = doMeasureAccurate( 'x' ).value;
            double tool = doMeasureTool( 'x' ).value;
            double d = Math.abs( acc - tool );
            if ( d > max ) {
                max = d;
                rotate = r;
            }
        }
        doGoTo( 'z', new Double( rotate ) );

    }
    /**
     * Задание ном погрешностей эталонных значений от УАКСИ.
     * Заполняются только не нулевые данные.
     */
    protected void assignAccDelta() {
        int tableCount = datas.size();
        for ( int i = 0; i < tableCount; i++ ) {
            MeasureTable table = datas.getTable( i );
            String type = table.getProperty( "type" );
            int index = 0; //
            if ( type.equals( "zenith" ) ) {
                index = 1;
            } else
            if ( type.equals( "rotate" ) ) {
                index = 2;
            }
            for ( int rr = 0; rr < table.size(); rr++ ) {
                MeasureChain mc = table.getChain( rr );
                int points = mc.size();
                for ( int pnt = 0; pnt < points; pnt++ ) {
                    MeasurePoint mp = mc.getPoint( pnt );
                    // изменяем значение только для не пустого замера
                    if (  !mp.isEmpty() ) {
                        mp.accurate.delta = UAKSI_ERRORS[index];
                    }

                }
            }
        }
    }

    protected void startProcess() {
        tracker.points.clear();
        execCommand( ( Command )cbDo.getSelectedItem() );
        System.out.println( "Process started" );
    }

    protected void execCommand( Command command ) {
        if ( executer != null ) {
            if ( executer.isAlive() ) {
                return;
            }
        }
        executer = new CommandExecuter( command );
        //executer.setDaemon(true);
        //System.out.println( "Process started" );
        executer.start();

    }

    void stopProcess( ActionEvent e ) {
        if ( executer != null ) {
            if ( executer.isAlive() ) {
                try {
                    unit.stop();
                } catch ( Exception ex ) {
                }
                timeUpdater.stop();
                clearMessages();
                //executer.interrupt();
                executer.stop();
                //executer.destroy();

            }
        }

    }

    protected void initTable( JTable table ) {
        TableColumn column = null;
        JTableHeader header = table.getTableHeader();
        header.setVisible( true );
        for ( int i = 0; i < 3; i++ ) {
            //table.getColumn
        }

    }

    void updateTime() {
        lTimeStart.setText( TextUtil.dateToString( startTime, "HH:mm:ss" ) );
        //ng mil = System.currentTimeMillis();
        Date elapsed = new Date();
        long mil = elapsed.getTime() - startTime.getTime();
        //elapsed.set(Calendar.ZONE_OFFSET, 0);
        //elapsed.setTimeZone(TimeZone.getTimeZone("GMT+0000"));
        //elapsed.setTimeInMillis(mil);
        lTimeElapsed.setText( TextUtil.millisToString( mil ) );
    }

    void clearMessages() {
        lMessage1.setText( "" );
        lMessage2.setText( "" );
        lMessage3.setText( "" );

    }

    void switchOff() {
        if ( unit != null ) {
            //unit.removeAllListeners();
            unit.removeSignalListeners();
            unit.disconnect();
        }
    }

    void quit() {
        if ( JOptionPane.showConfirmDialog( this, "Выйти?",
                                            "Выход из модуля",
                                            JOptionPane.YES_NO_OPTION ) == 0 ) {
            switchOff();
            dispose();
        }

    }

    /*
         protected Vector buildCommandList() {
        char plane = 'z';
        MeasureTable workTable = tables[2].measureTable;
        int pointsCount = workTable.size();
        Vector commands = new Vector( 16 );
        MethodsCommand command = new MethodsCommand( "selectPlane",
            "Выбор плоскости " + plane );
        command.setArgument( new Character( plane ) );
        commands.add( command );
        for ( int i = 0; i < pointsCount; i++ ) {
            double value = workTable.getChain( i ).getReproductionValue();
            command = new MethodsCommand( "goToPoint",
                                          "Выход на точку " + value );
            command.setArgument( new Double( value ) );
            commands.add( command );
        }
        return commands;
         }*/

    void buildToolLabel() {
        StringBuffer str = new StringBuffer(
            "<html><table width=200 border=1><tr><th>" );
        str.append( toolAngles.azimuth.toString() );
        str.append( "</th><th>" );
        str.append( toolAngles.zenith.toString() );
        str.append( "</th><th>" );
        str.append( toolAngles.rotate.toString() );
        str.append( "</th></tr></table>" );
    }

    void switchConnect() {
        try {
            if ( !unit.isConnected() ) {
                unit.connect();
            }
        } catch ( Exception ex ) {
            UiUtils.showError( this,
                               "Не удалось подключиться: " + ex.getMessage() );
            //System.err.println( ex.getMessage() );
        }
        try {
            if ( !toolSource.isConnected() ) {
                toolSource.connect();
            }
        } catch ( Exception ex ) {
            UiUtils.showError( this,
                "Не удалось подключиться к источку данных прибора: " +
                ex.getMessage() );
            //System.err.println( ex.getMessage() );
        }
    }

    void bConnect_actionPerformed( ActionEvent e ) {
        //bConnect.setSelected( unit.isConnected() );

        if ( unit.isConnected() ) {
            bConnect.setIcon( iconOn );
        } else {
            bConnect.setIcon( iconOff );
        }
    }

    private class CommandExecuter
        extends Thread {
        private AbstractCheckUnit unit;
        private Vector commandList;
        private Command command;
        public CommandExecuter( Command command ) {
            this.command = command;
            //this.unit = unit;
            //this.commandList = commandList;
        }

        public void run() {

            try {
                startTime = new Date();
                updateTime();
                timeUpdater.start();
                timeUpdater.setRepeats( true );
                command.execute();
                timeUpdater.stop();
            } catch ( Exception ex ) {
                System.err.println( ex.getCause().getMessage() );
            }
            finally {
                timeUpdater.stop();
            }
            //doCalibrationRotate();
            /*
                                      int size = commandList.size();
                                      for ( int i = 0; i < size; i++ ) {
                 MethodsCommand command = ( MethodsCommand ) commandList.get( i );
                                          try {
                                              command.invoke( unit );
                                          } catch ( Exception ex ) {
                              System.err.println( ex.getCause().getMessage() );
                                          }
                                      }*/
        }
    }


    void bSave_actionPerformed( ActionEvent e ) {
        DataFactory.saveMeasureDatas( datas );
    }

    void cbZenRotates_actionPerformed( ActionEvent e ) {
        changeZenithTable();
    }

    void bStart_actionPerformed( ActionEvent e ) {

    }

    void bConnect_stateChanged( ChangeEvent e ) {
        switchConnect();
    }

    protected void processWindowEvent( WindowEvent e ) {
        super.processWindowEvent( e );
        if ( e.getID() == WindowEvent.WINDOW_CLOSING ) {
            quit();
            //System.exit( 0 );
        }
    }

    void bJoin_actionPerformed( ActionEvent e ) {
        try {
            doJoinRotates();
        } catch ( Exception ex ) {
        }
    }

    void cbAzZeniths_actionPerformed( ActionEvent e ) {
        changeAzimuthTable();
    }

    void bProtocol_actionPerformed( ActionEvent e ) {
        try {
            String path = Zeus.getInstance().getProperty( "report.path" );
            FileWriter file = new FileWriter( path + "/" + datas.getToolType() +
                                              "_" + datas.getToolNumber() +
                                              ".html" );
            StringWriter out = new StringWriter( 8192 );
            IMProtocol prot = new IMProtocol( out );
            prot.generate( datas );
            out.flush();
            file.write( out.toString() );
            file.close();
            HtmlViewer htmlViewer = new HtmlViewer();
            htmlViewer.setText( out.toString() );
            htmlViewer.view();
            out.close();
        } catch ( Exception ex ) {
        }

    }

}
